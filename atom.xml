<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://justin-xiang.github.io</id>
    <title>小翔的小站</title>
    <updated>2021-03-30T02:12:59.958Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://justin-xiang.github.io"/>
    <link rel="self" href="https://justin-xiang.github.io/atom.xml"/>
    <subtitle>悟以往之不谏 知来者知可追</subtitle>
    <logo>https://justin-xiang.github.io/images/avatar.png</logo>
    <icon>https://justin-xiang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 小翔的小站</rights>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://justin-xiang.github.io/post/about/</id>
        <link href="https://justin-xiang.github.io/post/about/">
        </link>
        <updated>2021-03-12T03:12:49.000Z</updated>
        <summary type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝</p>
</blockquote>
<!-- more -->
<h2 id="关于本站">🏠 关于本站</h2>
<p>记录一些学习笔记 或者 生活中的一些值得写下来的事情</p>
<h2 id="博主是谁">👨‍💻 博主是谁</h2>
<p>武汉某985 大二计算机学院学生</p>
<h2 id="兴趣爱好">⛹ 兴趣爱好</h2>
<p>包括但不限于<br>
* 折腾数码⌚️📱💻<br>
* 折腾无人机🚁<br>
* 到处旅游🏄<br>
* 拍拍照片📷<br>
* 看看电影🎥<br>
* 打打游戏🎮</p>
<h2 id="联系我呀">📬 联系我呀</h2>
<p><a href="https://github.com/Justin-Xiang">Github</a><br>
<a href="https://twitter.com/justinxharold1">Twitter</a><br>
Gmail: liao1120x@gmail.com</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS入门课程笔记(含七节思考题+随堂小测)]]></title>
        <id>https://justin-xiang.github.io/post/ios-ru-men-ke-cheng-bi-ji-han-qi-jie-si-kao-ti-sui-tang-xiao-ce/</id>
        <link href="https://justin-xiang.github.io/post/ios-ru-men-ke-cheng-bi-ji-han-qi-jie-si-kao-ti-sui-tang-xiao-ce/">
        </link>
        <updated>2021-02-03T15:56:04.000Z</updated>
        <summary type="html"><![CDATA[<p>在飞书上写的 搬过来不太美观 这里只放链接<br>
https://bytedancecampus1.feishu.cn/docs/doccnXdFOwC0q5Jc078FYLHhSKe</p>
]]></summary>
        <content type="html"><![CDATA[<p>在飞书上写的 搬过来不太美观 这里只放链接<br>
https://bytedancecampus1.feishu.cn/docs/doccnXdFOwC0q5Jc078FYLHhSKe</p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Objective-C 的学习之旅]]></title>
        <id>https://justin-xiang.github.io/post/objective-c-de-xue-xi-zhi-lu/</id>
        <link href="https://justin-xiang.github.io/post/objective-c-de-xue-xi-zhi-lu/">
        </link>
        <updated>2021-01-28T15:50:18.000Z</updated>
        <summary type="html"><![CDATA[<p>在飞书上写的 搬过来影响美观 这里只放链接<br>
https://bytedancecampus1.feishu.cn/docs/doccnqkrcGfzlftUBs3Bg4h1fjg#</p>
]]></summary>
        <content type="html"><![CDATA[<p>在飞书上写的 搬过来影响美观 这里只放链接<br>
https://bytedancecampus1.feishu.cn/docs/doccnqkrcGfzlftUBs3Bg4h1fjg#</p>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[K-means聚类算法在数据化运营的应用]]></title>
        <id>https://justin-xiang.github.io/post/k-means-ju-lei-suan-fa-zai-shu-ju-hua-yun-ying-de-ying-yong/</id>
        <link href="https://justin-xiang.github.io/post/k-means-ju-lei-suan-fa-zai-shu-ju-hua-yun-ying-de-ying-yong/">
        </link>
        <updated>2020-04-17T15:48:35.000Z</updated>
        <summary type="html"><![CDATA[<p>K-means算法源于信号处理中的一种向量量化方法，现在则更多地作为一种聚类分析方法流行于数据挖掘领域</p>
]]></summary>
        <content type="html"><![CDATA[<p>K-means算法源于信号处理中的一种向量量化方法，现在则更多地作为一种聚类分析方法流行于数据挖掘领域</p>
<!-- more -->
<h2 id="k-means算法">K-means算法</h2>
<p>K-means算法源于信号处理中的一种向量量化方法，现在则更多地作为一种聚类分析方法流行于数据挖掘领域。K-means的目的是：把n个点(可以是样本的一次观察或一个实例)划分到K个聚类中，使得每个点都属于离他最近的均值(此即聚类中心)对应的聚类，以之作为聚类的标准。</p>
<p>这个问题在计算上是NP困难<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> ，不过存在高效的启发式算法。一般情况下，都使用效率比较高的启发式算法，它们能够快速收敛于一个局部最优解。这些算法通常类似于通过迭代优化方法处理高斯混合分布的最大期望算法<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup> 。而且，它们都使用聚类中心来为数据建模；然而K-means倾向于在可比较的空间范围内寻找聚类。</p>
<p>需要注意的是，K-means与K-NN算法之间没有任何关系。</p>
<h3 id="算法描述">算法描述</h3>
<p>已知观测集(x<sub>1</sub>,x<sub>2</sub>,...,x<sub>n</sub>),其中每个观测都是一个d-维实向量，K-means要把这n个观测值划分到k个集合中(k&lt;=n),使得组内平方和最小。换句话说，他的目标是找到使得下式满足的聚类S<sub>i</sub></p>
<figure data-type="image" tabindex="1"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/debd28209802c22a6e6a1d74d099f728e6bd17a4" alt="avatar" loading="lazy"></figure>
<p>其中u<sub>i</sub>是S<sub>i</sub>中所有点的均值</p>
<h3 id="算法">算法</h3>
<h4 id="标准算法">标准算法</h4>
<p>最常用的算法使用了迭代优化的技术。已知初始的<em>k</em>个均值点<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/cc5c8d20a34ab22bc8d60f0db3348972df3d6b6f" alt="m_{1}{{(1)}},...,m_{k}{{(1)}}" loading="lazy">,算法的按照下面两个步骤交替进行</p>
<ul>
<li>分配：将每个观测分配到聚类中，使得组内平方和达到最小</li>
</ul>
<p>因为这一平方和就是平方后的欧式距离，所以很直观地把观测分配到离它最近的均值点即可。</p>
<figure data-type="image" tabindex="2"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/2209c469376c291889d32f798652b1398497c484" alt="avatar" loading="lazy"></figure>
<p>其中每个<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/0bec554743fa797409a83ad8d00b4d35e110a50a" alt="avatar" loading="lazy">都只被分配到一个确定的聚类<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/b530fb2495d517c108d8429ccd6af1fa62e2ce0d" alt="S^{{t}}" loading="lazy">中，尽管在理论上它可能被分配到2个或者更多的聚类。</p>
<ul>
<li>更新：对于上一步得到的每一个聚类，以聚类中观测值的图心，作为新的均值点。</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/964165b4792e24484c3ccde9b3e00c478c96fbd6" alt="avatar" loading="lazy"></figure>
<p>因为算术平均是最小二乘估计，所以这一步同样减小了目标函数组内平方和的值。</p>
<p>这一算法将在对于观测的分配不再变化时收敛。由于交替进行的两个步骤都会减小目标函数组内平方和的值，并且分配方案只有有限种，所以算法一定会收敛于某一（局部）最优解。</p>
<p>注意：使用这一算法无法保证得到全局最优解。</p>
<p>这一算法经常被描述为“把观测按照距离分配到最近的聚类”。标准算法的目标函数是组内平方和，而且按照“最小二乘和”来分配观测，确实是等价于按照最小欧氏距离来分配观测的。如果使用不同的距离函数来代替（平方）欧氏距离，可能使得算法无法收敛。然而，使用不同的距离函数，也能得到<em>k</em>-均值聚类的其他变体，如球体<em>k</em>-均值算法和<em>k</em>-中心点算法。</p>
<h4 id="初始化方法">初始化方法</h4>
<p>通常使用的初始化方法有Forgy和随机划分方法。Forgy方法随机地从数据集中选择<em>k</em>个观测作为初始的均值点；而随机划分方法则随机地为每一观测指定聚类，然后运行“更新(Update)”步骤,即计算随机分配的各聚类的图心，作为初始的均值点。Forgy方法易于使得初始均值点散开，随机划分方法则把均值点都放到靠近数据集中心的地方。对于期望-最大化(EM)算法和标准<em>k</em>-均值算法，Forgy方法作为初始化方法的表现会更好一些。</p>
<h3 id="复杂度">复杂度</h3>
<p>在d维空间中找到K-means问题的最优解的时间复杂度为</p>
<figure data-type="image" tabindex="4"><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e4293c3302561badaa2cb684ea014ea88e74dea1" alt="avatar" loading="lazy"></figure>
<p>其中n为待聚类的观测点数目</p>
<h3 id="相关应用">相关应用</h3>
<h4 id="向量的量化">向量的量化</h4>
<p><em>k</em>-means起源于信号处理领域，并且现在也能在这一领域找到应用。例如在计算机图形学中，色彩量化的任务，就是要把一张图像的色彩范围减少到一个固定的数目<em>k</em>上来。<em>k</em>-means算法就能很容易地被用来处理这一任务，并得到不错的结果。其它得向量量化的例子有非随机抽样，在这里，为了进一步的分析，使用<em>k</em>-means算法能很容易的从大规模数据集中选出<em>k</em>个合适的不同观测</p>
<h4 id="聚类分析">聚类分析</h4>
<p>在聚类分析中，<em>k</em>-means算法被用来将输入数据划分到<em>k</em>个部分(聚类)中。 然而，纯粹的<em>k</em>-means算法并不是非常灵活，同样地，在使用上有一定局限（不过上面说到的向量量化，确实是一个理想的应用场景）。特别是，当没有额外的限制条件时，参数<em>k</em>是很难选择的（正如上面讨论过的一样）。算法的另一个限制就是它不能和任意的距离函数一起使用、不能处理非数值数据。而正是为了满足这些使用条件，许多其他的算法才被发展起来。</p>
<h4 id="特征学习">特征学习</h4>
<p>在（半）监督学习或无监督学习中，<em>k</em>-means被用来进行特征学习（或字典学习）步骤。基本方法是，首先使用输入数据训练出一个<em>k</em>-means表示，然后把任意的输入数据投射到这一新的特征空间。 <em>k</em>-means的这一应用能成功地与自然语言处理和计算机视觉中半监督学习的简单线性分类器结合起来。在对象识别任务中，它能展现出与其他复杂特征学习方法（如自动编码器、受限Boltzmann机等）相当的效果。然而，相比复杂方法，它需要更多的数据来达到相同的效果，因为每个数据点都只贡献了一个特征（而不是多重特征）。</p>
<h3 id="简单实现">简单实现</h3>
<h4 id="代码块">代码块</h4>
<pre><code class="language-Python"># -*- coding: UTF-8 -*-
import numpy
import random
import matplotlib.pyplot as plt


def findCentroids(data_get, k):  # 随机获取k个质心

    return random.sample(data_get, k)


def calculateDistance(vecA, vecB):  # 计算向量vecA和向量vecB之间的欧氏距离

    return numpy.sqrt(numpy.sum(numpy.square(vecA - vecB)))


def minDistance(data_get, centroidList):
    # 计算data_get中的元素与centroidList中k个聚类中心的欧式距离，找出距离最小的
    # 将该元素加入相应的聚类中

    clusterDict = dict()  # 用字典存储聚类结果
    for element in data_get:
        vecA = numpy.array(element)  # 转换成数组形式
        flag = 0  # 元素分类标记，记录与相应聚类距离最近的那个类
        minDis = float(&quot;inf&quot;)  # 初始化为最大值

        for i in range(len(centroidList)):
            vecB = numpy.array(centroidList[i])
            distance = calculateDistance(vecA, vecB)  # 两向量间的欧式距离
            if distance &lt; minDis:
                minDis = distance
                flag = i  # 保存与当前item距离最近的那个聚类的标记

        if flag not in clusterDict.keys():  # 簇标记不存在，进行初始化
            clusterDict[flag] = list()
        clusterDict[flag].append(element)  # 加入相应的类中

    return clusterDict  # 返回新的聚类结果


def getCentroids(clusterDict):
    centroidList = list()
    for key in clusterDict.keys():
        centroid = numpy.mean(numpy.array(clusterDict[key]), axis=0)  # 求聚类中心即求解每列的均值
        centroidList.append(centroid)

    return numpy.array(centroidList).tolist()


def calculate_Var(clusterDict, centroidList):
    # 计算聚类间的均方误差
    # 将类中各个向量与聚类中心的距离进行累加求和

    sum = 0.0
    for key in clusterDict.keys():
        vecA = numpy.array(centroidList[key])
        distance = 0.0
        for item in clusterDict[key]:
            vecB = numpy.array(item)
            distance += calculateDistance(vecA, vecB)
        sum += distance

    return sum


def showCluster(centroidList, clusterDict):
    # 画聚类结果

    colorMark = ['or', 'ob', 'og', 'ok', 'oy', 'ow']  # 元素标记
    centroidMark = ['dr', 'db', 'dg', 'dk', 'dy', 'dw']  # 聚类中心标记
    for key in clusterDict.keys():
        plt.plot(centroidList[key][0], centroidList[key][1], centroidMark[key], markersize=12)  # 画聚类中心
        for item in clusterDict[key]:
            plt.plot(item[0], item[1], colorMark[key])  # 画类下的点

    plt.show()


data = [[0.0, 0.0], [3.0, 8.0], [2.0, 2.0], [1.0, 1.0], [5.0, 3.0],
        [4.0, 8.0], [6.0, 3.0], [5.0, 4.0], [6.0, 4.0], [7.0, 5.0]]

if __name__ == '__main__':

    centroidList = findCentroids(data, 3)  # 随机获取3个聚类中心
    clusterDict = minDistance(data, centroidList)  # 第一次聚类迭代
    newVar = calculate_Var(clusterDict, centroidList)  # 计算均方误差值，通过新旧均方误差来获得迭代终止条件
    oldVar = -0.0001  # 初始化均方误差

    print('***** 第1次迭代 *****')
    for key in clusterDict.keys():
        print('聚类中心: ', centroidList[key])
        print('对应聚类: ', clusterDict[key])
    print('平均均方误差: ', newVar)
    showCluster(centroidList, clusterDict)  # 展示聚类结果

    k = 2
    while abs(newVar - oldVar) &gt;= 0.0001:  # 当连续两次聚类结果差距小于0.0001时，迭代结束
        centroidList = getCentroids(clusterDict)  # 获得新的聚类中心
        clusterDict = minDistance(data, centroidList)  # 新的聚类结果
        oldVar = newVar
        newVar = calculate_Var(clusterDict, centroidList)

        print('***** 第%d次迭代 *****' % k)

        for key in clusterDict.keys():
            print('聚类中心: ', centroidList[key])
            print('对应聚类: ', clusterDict[key])
        print('平均均方误差: ', newVar)
        showCluster(centroidList, clusterDict)  # 展示聚类结果

        k += 1
</code></pre>
<h4 id="测试结果">测试结果</h4>
<figure data-type="image" tabindex="5"><img src="https://i.loli.net/2020/06/04/ZObW5gzfDmhdLuo.png" alt="avatar" loading="lazy"></figure>
<h2 id="应用场景描述">应用场景描述</h2>
<p>在数据化运营方面，聚类分析的一个重要用途就是目标群体进行多指标的群体划分，而类似这种目标群体的分类常常就是精细化运营，个性化运营的基础和核心，只有进行了正确的分类，才可以有效进行个性化和精细化的运营，服务及产品支持等。从这个角度来看，聚类分析技术对于数据化运营是非常重要和基础的。</p>
<p>总的来说，聚类分析技术在数据化运营实践中常见的业务应用场景如下：</p>
<ul>
<li>目标用户的群体分类：通过为特定运营目的和商业目的所挑选出的指标变量进行聚类分析，把目标群体划分成几个具有明显特征区别的细分群体，从而可以在运营活动中为这些细分群体采用精细化、个性化的运营和服务，最终提升运营的效率和商业的效果。</li>
<li>不同产品的价值组合：企业可以按照不同的商业目的，并依照特定的指标变量来为众多的产品种类进行聚类分析，把企业的产品体系进一步细分成具有不同价值、不同目的多维度的产品组合，并且可在此基础上分别制定相应的产品开发计划、运营计划和服务规划。</li>
<li>探测，发现孤立点，异常值：孤立点就是指相对于整体数据对象而言的少数数据对象，这些对象的行为特征与整体的数据行为特征很不一致。虽然在一般的数据处理过程中会把孤立点作为噪声而剔除出去，但是在许多业务领域里，孤立点的价值非常重要。比如说，互联网的风险管理里，就非常强调对于风险的预防和预判，而相关的风险控制分析中的孤立点很多时候又是风险的最大嫌疑和主要来源。及时发现这些特殊行为对于互联网的风险管理来说至关重要。比如，某B2C电商平台上，比较昂贵的、频繁的交易，就有可能隐含着欺诈的风险成分，需要风控部门提前关注、监控，防患于未然。</li>
</ul>
<h2 id="方法步骤">方法步骤</h2>
<h3 id="处理数据噪声和异常值">处理数据噪声和异常值</h3>
<p>K-Means算法对噪声和异常值非常敏感，这些个别数据对于平均值的影响非常大，鉴于K-means算法的这一局限性，我们在使用该算法时需要特别注意这些数据噪音和异常值。</p>
<p>常见的处理方法有：</p>
<ul>
<li>直接删除那些比其他任何数据点都要远离数据中心点的异常值。但同时为了防止误删，数据分析师需要监控这些异常值进行对比后再决定是否删除这些异常值。</li>
<li>使用随机抽样的方法。数据噪音和异常值本来就很少，因此被随机抽进样本中的概率很低。</li>
</ul>
<h3 id="数据标准化">数据标准化</h3>
<p>在数据化运营中，参与聚类的变量绝大多数都是区间型变量，不同区间型变量之间的数量单位不同，如果不进行标准化处理，容易造成聚类结果的失真。比如长度单位有的是公里，有的是米，有的是毫米。质量单位有的是吨，有的是克。因此为了避免这些影响，在聚类之前要采取的一个重要技术措施就是进行数据标准化。</p>
<p>数据标准化有许多方法。其中，标准差标准化最常用，又叫Z-score标准化，经过这种方法处理后的数据符合标准正态分布。</p>
<pre><code class="language-Python">def z_score(x, axis):
    x = np.array(x).astype(float)
    xr = np.rollaxis(x, axis=axis)
    xr -= np.mean(x, axis=axis)
    xr /= np.std(x, axis=axis)
    # print(x)
    return x
</code></pre>
<h3 id="聚类变量少而精">聚类变量少而精</h3>
<p>在聚类分析中，参与聚类的指标变量不能太多，如果太多，一方面会显著增加运算的时间，更重要的是变量之间或多或少的相关性会严重损害聚类的效果。因此，如何精心挑选特定的少数变量参与聚类也是聚类分析应用中的有一个关键点</p>
<h3 id="伪代码">伪代码</h3>
<figure data-type="image" tabindex="6"><img src="https://i.loli.net/2020/06/04/xJC1rm7WZnHfR64.png" alt="avatar" loading="lazy"></figure>
<h3 id="结果评估">结果评估</h3>
<p>通过聚类分析，业务方从所有用户中提取出两个群体：</p>
<ul>
<li>群体A：占样本数量的15%，主要特征为：全部是企业俱乐部用户，全部有在线交易历史，俱乐部年限小于4年，登录次数大于110次，访问量大于10 000。</li>
<li>群体B：占样本数量的10%，主要特征为：全部是个人俱乐部用户，全部有在线交易历史，俱乐部年限小于2年，登录次数大于100次，并且俱乐部指数小于80。</li>
</ul>
<p>运营方根据上述两个群体特征，提取出满足上述阈值的20000潜在目标用户，并进行1周的定向在线运营活动，通过3轮营销推广活动，最后付费转换率为4.69%</p>
<p>作为对比，2006年，世界知名的计算机硬件和软件系统服务提供商Oracle公司在中国市场做过一次比较成功的定向运营推广活动。先向200 000企业高层相关人士通过EDM（电子邮件营销）、Banner（官方网站的横幅广告）、直邮、电话访问以及夹报广告等各种传播方式传达Oracle的产品理念，经过两个月运营，有20 000目标受众对此表示出了兴趣，其阅读了宣传资料或者访问了产品宣传网站，进一步跟进，有2000人填写了反馈问卷，并下载了相关资料，最终，Oracle得到了900个销售机会。Oracle公司本次为期3个月的定向运营，得到的销售计划转化率为0.45%。</p>
<p>可以看见，经过K-means算法聚类分析后的准确投放，转换率得到了大大的提高。</p>
<h2 id="优缺点分析">优缺点分析</h2>
<p>聚类分析的优势在实践中十分明显，尤其是在针对大数据集的时候，具体来讲，其应用优势体现在以下几个方面：</p>
<ul>
<li>目前聚类技术十分成熟，算法可靠，长期的商业实践已经证明它是一个很好的数据群体细分的工具和方法</li>
<li>K-means算法简洁，高效。前面已经说了它的时间复杂度。可以看见K-means算法的时间复杂度与数据集的大小是线性相关的。</li>
<li>K-means算法不依赖顺序，给定一个初始分布，无论顺序如何，聚类过程结束后的数据分区结果都是一样的。</li>
</ul>
<p>说了这几个优点，那么它的缺点呢？</p>
<ul>
<li>如前所述，K-means算法对数据噪音和异常值比较敏感。</li>
<li>同时，K-means算法的K需要事先指定聚类的数目k。在实践中，要测试多个不同的k值才能根据效果比较来选择最合适的K值，这个过程可能会比较耗时。</li>
</ul>
<h2 id="优化k-means算法">优化——K-means++算法</h2>
<h3 id="缘由">缘由</h3>
<p>由于K-means算法的分类结果会受初始点的选取而有所区别，因此提出了K-means++这一算法</p>
<h3 id="算法步骤">算法步骤</h3>
<p>只是对初始点的选择有改进，其余步骤都一样。初始质心选取的基本思想就是：初始的聚类中心之间的相互距离要尽可能的远。</p>
<figure data-type="image" tabindex="7"><img src="https://images2018.cnblogs.com/blog/1366181/201804/1366181-20180402200209017-1976662980.png" alt="avatar" loading="lazy"></figure>
<h2 id="参考">参考</h2>
<ul>
<li>https://en.wikipedia.org/wiki/K-means_clustering</li>
<li>https://en.wikipedia.org/wiki/K-means%2B%2B</li>
<li>https://www.cnblogs.com/wang2825/articles/8696830.html</li>
<li>《数据挖掘与数据化运营实战：思路、方法、技巧与应用》</li>
</ul>
<p>p</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>介绍NP困难之前要说到P问题和NP问题，P问题是在多项式时间内可以被解决的问题，而NP问题实在多项式时间内可以被验证其正确性的问题。NP困难问题是计算复杂性理论中最重要的复杂性类之一。如果所有NP问题都可以多项式时间归约到某个问题，则称该问题为NP困难。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>在统计中被用于寻找，依赖于不可观察的隐性变量的概率模型中，参数的最大似然估计。 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[彻底搞清楚指针！]]></title>
        <id>https://justin-xiang.github.io/post/che-di-gao-qing-chu-zhi-zhen/</id>
        <link href="https://justin-xiang.github.io/post/che-di-gao-qing-chu-zhi-zhen/">
        </link>
        <updated>2020-03-17T15:43:43.000Z</updated>
        <summary type="html"><![CDATA[<p>指针其实就是一个特殊的变量，虽然叫做指针，但如果理解成“指向”的话就很难理解，事实上，“指针”通常用于保存一个地址，而这个地址的类型在声明指针变量时确定</p>
]]></summary>
        <content type="html"><![CDATA[<p>指针其实就是一个特殊的变量，虽然叫做指针，但如果理解成“指向”的话就很难理解，事实上，“指针”通常用于保存一个地址，而这个地址的类型在声明指针变量时确定</p>
<!-- more -->
<h2 id="指针">指针</h2>
<h3 id="什么是指针">什么是指针？</h3>
<p>指针其实就是一个特殊的变量，虽然叫做指针，但如果理解成“指向”的话就很难理解，事实上，“指针”通常用于保存一个地址，而这个地址的类型在声明指针变量时确定</p>
<p>来看一个例子</p>
<pre><code class="language-c">int a;    //声明一个int型变量
int *b;   //声明一个指针变量b，用于保存一个地址
          //地址所保存的数据为int型
int *c;   //同上
b = &amp;a;   //把变量a的地址赋给b，“&amp;”是取变量地址的操作
c = b;    //将b的值赋给c，现在b和c的值都是a的地址
</code></pre>
<h3 id="指针的类型">指针的类型</h3>
<p>只需要把指针声明语句中的指针名字去掉，剩下的部分就是指针的类型</p>
<pre><code class="language-c">int *a;   //指针类型为int *
char *a;  //指针类型为char *
int **a;  //指针类型为int **
int(*a)[3]; //指针类型为int(*)[3]
int*(*a)[3]; //指针类型为int*(*)[3]
</code></pre>
<h3 id="指针所指向的类型">指针所指向的类型</h3>
<p>指针所指向的类型决定了编译器将那片内存区里的内容当做什么来看待</p>
<p>只需要把指针声明语句中的指针名字和左边的*去掉，就是指针所指向的类型</p>
<pre><code class="language-c">int *a;    //指针所指向的类型为int
char *a;   //指针所指向的类型为char
int **a;   //指针所指向的类型为int *
int*(*a)[4] //指针所指向的类型为int*()[4]
</code></pre>
<p>注意，<strong>指针的类型</strong>和<strong>指针所指向的类型</strong>是两个概念</p>
<h3 id="指针的值">指针的值</h3>
<p>指针的值是指针本身存储的数值，又叫指针所指向的内存区或地址，这个值被编译器当做一个地址，而不是一个一般的数值</p>
<p>在32位程序中，所有类型的指针的值都是一个32位整数，因为32位程序里内存地址全都是32位长。</p>
<p>指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为sizeof(指针所指向的类型)的一片内存区域。</p>
<p>我们说一个指针指向了某块内存区域，就相当于说该指针的值就是这块内存区域的首地址。</p>
<p>应该注意到，<strong>指针所指向的内存区</strong>和<strong>指针所指向的类型</strong>是两个完全不同的概念</p>
<h2 id="两种运算符">两种运算符</h2>
<p><strong>&amp;<strong>是</strong>取地址运算符</strong></p>
<p>&amp;a 的运算结果是一个<strong>指针</strong>，指针的类型是a的类型加上*，指针所指向的类型是a的类型，指针所指向的地址就是a的地址</p>
<p>*<strong><strong>是</strong>间接运算符</strong></p>
<p>*a就是引用这个a的地址所保存的变量，类型是a指向的类型，占用的地址是a所指向的地址，</p>
<p>来看例子！</p>
<pre><code class="language-c">int a = 12;
int b;
int *c;
int **d;
c = &amp;a; //&amp;a的结果是一个指针，类型是int *，指向的类型是int，
        //指向的地址是a的地址
*c = 24;//*c的结果，类型是int,占用的地址是c所指向的地址
        //显然，*c就是变量a
d = &amp;c; //&amp;c的结果是一个指针，类型是c的类型加一个*，也就是
        //int **,该指针所指向的类型是c的类型，也就是int *
        //所指向的地址就是c的地址
*d = &amp;b;//*d是一个指针，&amp;b也是一个指针，且*d的类型为&amp;c所指向的
        //类型，为int *,所以*d和&amp;b这两个指针的类型和所指向的类型
        //是一样的，所以可以进行赋值
**d = 36;//*d是一个指针，在这里再做一次*运算，就是一个int类型
        //的变量
</code></pre>
<p>再来看一个结构指针的例子</p>
<pre><code class="language-c">struct node{
    int data;
    struct node *next;
};    //定义结构类型node
int main(void)
{
    struct node a;
    struct node *p = &amp;a;    //将结构体a的所占用内存的首地址
                            //赋给了结构指针p
    printf(&quot;%d&quot;,(*p).data); //利用取地址符运算取出指针p所指
                            //向结构体a中的data值
    //(*p).data可替换为p-&gt;data
}
</code></pre>
<h2 id="指针的算术运算">指针的算术运算</h2>
<p>指针可以加上或减去一个整数，这种运算和通常数值的加减运算的意义不一样，它是以单元为单位的。</p>
<p>来看例子</p>
<pre><code class="language-c">char a[20];
int *ptr = (int *)a;
ptr++;
</code></pre>
<p>指针ptr的类型为int *，指向的类型为int,初始化为指向整形变量a。</p>
<p>指针ptr加了1，编译器就把指针ptr的值加上了sizeof(int)</p>
<p>我们可以用一个指针和一个循环来遍历一个数组</p>
<pre><code class="language-c">int array[20] = {0};
int *ptr = array;
for(i=0;i&lt;20;i++)
{
    (*ptr)++;
    ptr++;
}
</code></pre>
<p>这个例子就是将整型数组中每个单元的值加1，然后再将指针ptr加一个单元，使之能够访问数组的下一个单元</p>
<p>再来看一个例子</p>
<pre><code class="language-c">int main(void)
{
    char a[20]=&quot;you are a student&quot;;
    char *p=a;
    char **ptr = &amp;p;
    printf(&quot;**ptr=%c\n&quot;,**ptr);
    ptr++;
    printf(&quot;**ptr=%c\n&quot;,**ptr);
}
</code></pre>
<p>ptr的类型为char **,指向的类型为char *,指向的地址就是p的地址，当执行ptr++时，会使指针加上sizeof(char *)，也就是&amp;p+4,那 * (&amp;p+4)指向哪呢？这个我们就不知道了</p>
<p>所以最后的输出可能是一个随机的值，也有可能是一个非法操作</p>
<h3 id="总结">总结</h3>
<p>一个指针ptrold加（减）一个整数n后，结果是一个新的指针ptrnew,ptrnew的类型和ptrold的类型相同，ptrnew所指向的类型和ptrold所指向的类型也相同，ptrnew的值将比ptrold的值增加（减少）n*sizeof(ptrold所指向的类型)个字节</p>
<h2 id="指针与数组">指针与数组</h2>
<p>数组的数组名其实就可以看作一个指针</p>
<pre><code class="language-c">int array[10]={0,1,2,3,4,5,6,7,8,9};
int value;
value = array[0];    //也可以写成:value=*array
value = array[3];    //也可以写成:value=*(array+3)
value = array[9];    //也可以写成:value=*(array+9)
</code></pre>
<p>如果把array看成指针的话，它指向数组的第0个单元，类型是int *，所指向的类型自然就是int</p>
<pre><code class="language-c">char *str[3]={
    &quot;Hello,this is a example&quot;,
    &quot;Hi,good morning&quot;,
    &quot;Hello,world&quot;
};
char s[80];
strcpy(s,str[0]);  //也可以写成strcpy(s,*str);
strcpy(S,str[1]);  //也可以写成strcpy(s,*(str+1));
strcpy(s,str[2]);  //也可以写成strcpy(s,*(str+2));
</code></pre>
<p>str是一个三单元的数组，该数组的每个单元都是一个指针，这些指针各指向一个字符串，如果把str看作一个指针的话，它指向数组的第0号单元，类型是char **，指向的类型是char *</p>
<p>*str也是一个指针，它的类型是char *,它指向的类型是char，它指向的地址是字符串&quot;Hello,this is a example&quot;的第一个字符的地址，即'H'的地址</p>
<p>str+1也是一个指针，它指向数组的第1号单元，它的类型是char **,它指向的类型是char *</p>
<p>*(str+1)也是一个指针，它的类型是char *,它所指向的类型是char,它指向&quot;Hi,good morning&quot;的第一个字符'H'</p>
<p>当我们声明一个数组TYPE array[n]时，数组名称array就有了两重含义</p>
<ul>
<li>它代表整个数组，类型是TYPE[n]</li>
<li>它是一个常量指针，指针的类型是TYPE *，指向的类型是TYPE，指向的内存区是数组第0号单元</li>
</ul>
<p>再来看不同表达式中array不同的作用</p>
<ul>
<li>在sizeof(array)中，array代表数组本身，因此此时sizeof函数测出的是整个数组的大小</li>
<li>在*array中，array是指针，因此 * array的结果是数组第0号单元的值，sizeof(*array)测出的是数组单元的大小</li>
<li>array+n中,arrray是指针,array+n也是指针，它指向数组第n号元素</li>
</ul>
<h2 id="指针与函数">指针与函数</h2>
<h3 id="指针作为函数的参数">指针作为函数的参数</h3>
<p>通过将地址当做实参传给函数中形参（指针），完成赋值</p>
<p>例如冒泡排序</p>
<pre><code class="language-c">void exchange(int *p,int *q)
{
    int temp;
    temp = *q;
    *q = *p;
    *p = temp;
}

int main(){
    int a[10]={3,4,5,1,6,7,8,9,10,0};
	for(int i=0;i&lt;10;i++){
		for(int j=9-i;j&gt;=0;j--){
			if(a[j]&lt;a[j-1]){
				exchange(&amp;a[j-1],&amp;a[j]);
			}
		}
	}	
	for(int i=0;i&lt;10;i++){
		printf(&quot;%d&quot;,a[i]);
	} 
}
</code></pre>
<h3 id="指针作为函数的返回值">指针作为函数的返回值</h3>
<p>输入一个字符串和一个字符，如果该字符在字符串中，就从该字符首次出现的位置开始输出字符串中的数字</p>
<pre><code class="language-c">char *match(char str[],char a){
	int i=0;
	char *p;
	while(1){
		if(str[i]==a){
			p=&amp;str[i];
			return p;
		} 
		i++;
	}
}

int main(){
	char str[20];
	int i=0;
	char *q;
	 
	while((str[i]=getchar())!='\n'){
		i++;
	}
	str[i]='\0';
	q=match(str,'a');  //调用match函数，寻找相同的值 	
	printf(&quot;%s&quot;,q);    
}
</code></pre>
<h3 id="指向函数的指针">指向函数的指针</h3>
<p>可以把一个指针声明成为一个指向函数的指针</p>
<pre><code class="language-c">int fun1(char *,int);
int (*pfun1)(char *,int);
pfun1 = fun1;
int a=(*pfun1)(&quot;abcdefg&quot;,7);   //通过函数指针调用函数
</code></pre>
<p>可以把指针作为函数的形参</p>
<p>在函数调用语句中，可以用指针表达式作为实参</p>
<pre><code class="language-c">int fun(char *);
int a;
char str[]=&quot;abcdefghijklmn&quot;;
a=fun(str);
int fun(char *s)
{
    int num=0;
    for(int i=0;;)
    {
        num+=*s;s++;
    }
    return num;
}
</code></pre>
<p>函数fun统计一个字符串中各个字符的ASCII码值之和</p>
<h2 id="指针与结构类型">指针与结构类型</h2>
<p>可以声明一个指向数据结构类型对象的指针</p>
<pre><code class="language-c">struct Mystruct
{
    int a;
    int b;
    int c;
};
struct Mystruct ss={20,30,40};
struct Mystruct *ptr = &amp;ss;
//声明一个指向结构对象ss的指针
//类型是Mystruct *,指向类型是Mystruct
//通过ptr访问三个成员变量
ptr-&gt;a;
ptr-&gt;b;
ptr-&gt;c;
int *pstr = (int *)&amp;ss;
//声明一个指向结构对象ss的指针
//但指向的类型与ptr不同
//通过pstr访问三个成员变量
*pstr;  //访问a
*(pstr+1);  //访问b
*(pstr+2);  //访问c
//注意，这样用pstr来访问实际上是不正规的
//因为在存放结构对象的各个成员时，有些情况
//需要在相邻两个成员之间加若干个“填充字节”
//这就导致*(pstr+1)不一定能访问到结构成员b
</code></pre>
<h2 id="复杂类型的指针">复杂类型的指针</h2>
<pre><code class="language-c">int p;//整型变量
int *p;
/*  从p开始，p先跟*结合，说明p是一个指针
再与int结合，说明指针指向的内容的类型为int
所以p是一个返回整型数据的指针   */
int p[3];
/*  p先跟[]结合，说明p是一个数组，再与int
结合，说明数组中的元素都是整型
所以p是一个由整型数据组成的数组   */
int *p[3];
/*  p先跟[]结合，说明p是一个数组，再与*结合
说明数组中的元素是指针类型，再与int结合，说明
数组里的元素是指针类型，再与int结合，说明指针
所指向的内容的类型是整型的，所以p是一个由
返回整型数据的指针所组成的数组  */
int (*p)[3];
/*  p先跟*结合，说明p是一个指针，然后再与[]
结合，说明指针指向内容为数组，再与int结合
所以p是一个指向由整型数据组成的数组的指针  */
int **p;
/*  p先跟*结合，说明p是一个指针，然后再与*结合
，说明指针所指向的元素是指针，然后再与int结合，说明
该指针所指向的元素是整型数据   */
int p(int);
/*  p先跟()结合，说明p是一个函数，然后进入()里分析
 说明该函数有一个整型变量的参数，再与int结合，说明
 函数的返回值是一个整型数据 */
int (*p)(int);
/*  从p处开始，先与*结合，说明p是一个指针，然后与()
结合，说明指针指向的是一个函数，再与()里的int结合，说明
函数有一个int型的参数，再与最外层的int结合，说明函数
的返回类型是整型，所以p是一个指向有一个整型参数且返回
类型为整型的函数的指针  */
int *(*p(int))[3];
/*  从p开始，先与()结合，说明p是一个函数，然后()里，
说明函数有一个整型变量参数，再与外面的*结合，说明函数
返回的是一个指针，然后到最外面一层，先与[]结合，说明
返回的指针指向的是一个数组，再与*结合，说明数组里的元素是
指针，最后与int结合，说明指针指向的内容是整型数据
所以p是一个参数为一个整型数据且返回一个指向由整型指针
变量组成的数组的指针变量的函数*/
</code></pre>
<h2 id="后记">后记</h2>
<p>因为水平有限，所以可能有些地方讲的不是很清楚或者不充分，主要是鉴于自己在指针这方面有一些不理解，所以参考了网上的一些资料后整理下来的，多有纰漏，还望多多指教</p>
<p>写了这么多，最重要的还是要会用指针解决一些问题，所以后续可能会添加一些题目，就先这样了。</p>
]]></content>
    </entry>
</feed>